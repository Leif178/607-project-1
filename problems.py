import numpy as npfrom scipy import integrateclass Oscillator():    '''    Oscillator is an object that defines the motion of a damped oscillator    :param b: numeric type,b is equivalent to the damping factor of the oscillator (usually gamma) which has units 1/s    :param omega: numeric type, omega is equivalent to the harmonic frequency (usually written as omega_0^2) which has units s^-2    :param tint: either a list or tuple, the first element, numeric type, represents the starting time, and the second element, numeric type, represents the end time units s    :param x0: numeric type, defines the starting postition of the harmonic oscillator    :param xdot0: numeric type, defines the starting velocity of the oscillator, keep in mind that x0 and xdot0 are set to 0 by default which would describe a system that doesn't oscillate'    '''    def __init__(self, b, omega, tint, x0=0, xdot0=0):        self.b = b        self.omega = omega        self.tint = tint        self.x0 = x0        self.xdot0 = xdot0    def euler(self, n):        '''        This function preforms and euler method integration to find the posistion of the oscillator as a function of time        Parameters        ----------        n : int            number of points to analyze inbetween the initial and final time        Returns        -------        t : ndarray            time series used to calculate x        x : ndarray            posistion series calculated with t        '''        step = (self.tint[1]-self.tint[0])/n        t = np.arange(self.tint[0], self.tint[1], step)        x = np.zeros(len(t))        xdot = np.zeros(len(t))        x[0] = self.x0        xdot[0] = self.xdot0        for i in range(len(t)-1):            xdoubledot = -self.b*xdot[i] - self.omega*x[i]            x[i+1] = x[i]+xdot[i]*(t[i+1]-t[i])+1/2*xdoubledot*(t[i+1]-t[i])**2            xdot[i+1] = xdot[i]+xdoubledot*(t[i+1]-t[i])        return t, x    def rk4m(self, n):        '''        This function preforms and 4th order Runge-Kutta method integration to find the posistion of the oscillator as a function of time        Parameters        ----------        n : int            number of points to analyze inbetween the initial and final time        Returns        -------        t : ndarray            time series used to calculate x        x : ndarray            posistion series calculated with t        '''        step = (self.tint[1]-self.tint[0])/n        t = np.arange(self.tint[0], self.tint[1], step)        x = np.zeros(len(t))        xdot = np.zeros(len(t))        x[0] = self.x0        xdot[0] = self.xdot0        for i in range(len(t)-1):            k0 = (t[i+1]-t[i])*xdot[i]            l0 = (t[i+1]-t[i])*(-self.b*xdot[i]-self.omega*x[i])            k1 = (t[i+1]-t[i])*(xdot[i]+1/2*l0)            l1 = (t[i+1]-t[i]) * \                (-self.b*(xdot[i]+1/2*l0)-self.omega*(x[i]+1/2*k0))            k2 = (t[i+1]-t[i])*(xdot[i]+1/2*l1)            l2 = (t[i+1]-t[i]) * \                (-self.b*(xdot[i]+1/2*l1)-self.omega*(x[i]+1/2*k1))            k3 = (t[i+1]-t[i])*(xdot[i]+l2)            l3 = (t[i+1]-t[i])*(-self.b*(xdot[i]+1/2*l2)-self.omega*(x[i]+k2))            x[i+1] = x[i] + 1/6*(k0+2*k1+2*k2+k3)            xdot[i+1] = xdot[i] + 1/6*(l0+2*l1+2*l2+l3)        return t, x    def rk4sp(self, n):        '''        This function puses the scipy library to compute the 4th order Runge-Kutta method integration to find the posistion of the oscillator as a function of time        Parameters        ----------        n : int            number of points to analyze inbetween the initial and final time        Returns        -------        t : ndarray            time series used to calculate x        x : ndarray            posistion series calculated with t        '''        step = (self.tint[1]-self.tint[0])/n        def odes(t, x):            dx = np.zeros((2))            dx[0] = x[1]            dx[1] = -self.b*x[1]-self.omega*x[0]            return dx        Xres = integrate.solve_ivp(            odes, self.tint, [self.x0, self.xdot0], method='RK45', max_step=step)        return Xres.t, Xres.y[0]class Gamma():    '''    Gamma is an object that contains the argument of a Gamma function and can be used to numerically calculate the value of the Gamma function    :param z: This positive numeric type is the argument of the Gamma function     '''    def __init__(self, z):        self.z = z    def rInt(self, m=100000, dt=.1):        '''        This method preforms uses a Reimann sum to approximate the Gamma function        Parameters        ----------        m : int, optional            Final computational distance in the integral . The default is 100000.        dt : int, optional            Step length in integral. The default is .1.        Returns        -------        ans : float            Approximate solution to Gamma(z)        '''        T = np.arange(0, m, dt)        ans = 0        for t in T:            ans += t**(self.z-1)*np.exp(-t)*dt        return ans    def trapInt(self, m=100000, dt=.1):        '''        This method preforms uses a Trapezoidal sum to approximate the Gamma function        Parameters        ----------        m : int, optional            Final computational distance in the integral . The default is 100000.        dt : int, optional            Step length in integral. The default is .1.        Returns        -------        ans : float            Approximate solution to Gamma(z)        '''        T = np.arange(0, m, dt)        ans = 0        for t in T:            ans += dt*(t**(self.z-1)*np.exp(-t)+(t+dt)                       ** (self.z-1)*np.exp(-(t+dt)))/2        return ans    def simpInt(self, m=100000, dt=.1):        '''        This method preforms uses Simpson's rule to approximate the Gamma function        Parameters        ----------        m : int, optional            Final computational distance in the integral . The default is 100000.        dt : int, optional            Step length in integral. The default is .1.        Returns        -------        ans : float            Approximate solution to Gamma(z)        '''        T = np.arange(0, m, dt)        ans = 0        for t in T:            ans += dt*(t**(self.z-1)*np.exp(-t)+(t+dt)**(self.z-1) *                       np.exp(-(t+dt))+4*((2*t+dt)/2)**(self.z-1)*np.exp(-(2*t+dt)/2))/6        return ans    def trapIntSp(self, m=100000, dt=.1):        '''        This method uses the scipy library to compute a trapezoidal sum to approximate the Gamma function        Parameters        ----------        m : int, optional            Final computational distance in the integral . The default is 100000.        dt : int, optional            Step length in integral. The default is .1.        Returns        -------        ans : float            Approximate solution to Gamma(z)        '''        T = np.arange(0, m, dt)        x = []        for t in T:            x.append(t**(self.z-1)*np.exp(-t))        return integrate.trapezoid(x, dx=dt)    def simpIntSp(self, m=100000, dt=.1):        '''        This method uses the scipy library to compute Simpson's rule to approximate the Gamma function        Parameters        ----------        m : int, optional            Final computational distance in the integral . The default is 100000.        dt : int, optional            Step length in integral. The default is .1.        Returns        -------        ans : float            Approximate solution to Gamma(z)        '''        T = np.arange(0, m, dt)        x = []        for t in T:            x.append(t**(self.z-1)*np.exp(-t))        return integrate.simpson(x, dx=dt)